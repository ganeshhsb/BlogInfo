package com.markata.ganesh_hs.di.dagger

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.markata.ganesh_hs.BlogActivity
import com.markata.ganesh_hs.common.AppApplication
import com.markata.ganesh_hs.data.blog.repo.Blog
import com.markata.ganesh_hs.data.blog.repo.BlogRepository
import com.markata.ganesh_hs.data.blog.repo.IBlogRepository
import com.markata.ganesh_hs.domain.blog.BlogTask
import com.markata.ganesh_hs.domain.blog.IBlogTask
import com.markata.ganesh_hs.ui.blog.BlogFragment
import com.markata.ganesh_hs.ui.blog.BlogFragmentViewModel
import dagger.Binds
import dagger.MapKey
import dagger.Module
import dagger.Provides
import dagger.android.ContributesAndroidInjector
import dagger.multibindings.IntoMap
import io.reactivex.Single
import java.lang.annotation.Documented
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import javax.inject.Scope
import kotlin.reflect.KClass

//@Documented
//@Scope
//@Retention(RetentionPolicy.RUNTIME)
//annotation class ActivityScoped
//
//
//@Scope
//@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)
//@Target(AnnotationTarget.TYPE, AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)
//annotation class FragmentScoped
//
///**
// * Annotation to be applied to a getter or setter function, that is stored in the binary output.
// * A [ViewModelKey] object will be the key in a Map generated by Dagger. The value will be the
// * ViewModel to be retrieved based on the key.
// *
// * See com.google.samples.apps.iosched.ui.schedule.ScheduleModule.bindScheduleFragmentViewModel
// * for an usage example.
// */
//@Target(
//    AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY_GETTER,
//    AnnotationTarget.PROPERTY_SETTER
//)
//@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)
//@MapKey
//annotation class ViewModelKey(val value: KClass<out ViewModel>)
//
//@Module
//class AppModule {
////    @Provides
////    fun provideContext(application: AppApplication): Context {
////        return application.applicationContext
////    }
//}
//
//
//@Module
//interface ActivityModule {
//
//    @ContributesAndroidInjector(modules = [BlogActivityModule::class])
//    fun provideBlogActivity(): BlogActivity
//
//    @Binds
//    fun provideBlogTask(blogTask:BlogTask):IBlogTask
//
//    @Binds
//    fun provideBlogRepository(blogTask:BlogRepository):IBlogRepository
//}

@Module
class RepoModule{
    @Provides
    fun provideRepo(): IBlogRepository {

            return object : IBlogRepository {
                override fun fetchBlog(): Single<Blog> {
                    val tenthChar = ' '
                    val templateString = "qwertyuio$tenthChar"
                    var content = ""
                    for (i in 1..5) {
                        content += templateString
                    }
                    return Single.just(Blog(content))
                }
            }

    }
}

//@Module
//interface BlogActivityModule {
//    @FragmentScoped
//    @ContributesAndroidInjector
//    fun provideBlogFragment(): BlogFragment
//
//    /**
//     * The ViewModels are created by Dagger in a map. Via the @ViewModelKey, we define that we
//     * want to get a [OnboardingViewModel] class.
//     */
//    @Binds
//    @IntoMap
//    @ViewModelKey(BlogFragmentViewModel::class)
//    fun bindOnboardingViewModel(viewModel: BlogFragmentViewModel): ViewModel
//
//}
//
//@Module
//@Suppress("UNUSED")
//interface ViewModelModule {
//
//    @Binds
//    fun bindViewModelFactory(factory: AppViewModelFactory):
//            ViewModelProvider.Factory
//}